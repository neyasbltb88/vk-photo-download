(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _downloadjs = _interopRequireDefault(require("downloadjs"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Класс для управления обработчиками внутри кнопки
var HandlersManager =
/*#__PURE__*/
function () {
  function HandlersManager() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, HandlersManager);

    // Переданный инстанс главного класса
    this.PhotoDownload = params.PhotoDownload; // Тип события по умолчанию для обработчиков

    this.default_event_name = 'click'; // Объект с перечислением всех возможных обработчиков

    this.handlers = {
      testHandler: this._testHandler,
      preventHandler: this._preventHandler,
      preventStopHandler: this._preventStopHandler,
      newTabHandler: this._newTabHandler,
      downloadHandler: this._downloadHandler
    };
  } // constructor
  // Установить один или несколько обработчиков на элемент
  // Если на элементе были другие обработчики - они удаляются
  // В итоге на элементе гарантировано только переданный набор обработчиков


  _createClass(HandlersManager, [{
    key: "set",
    value: function set(elem, handler_name) {
      var _this = this;

      var event_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.default_event_name;
      if (!elem || !handler_name) return false;
      var result = true; // Удаляем все уже имеющиеся обработчики

      this.removeAll(elem, event_name); // Ставим нужные

      if (handler_name instanceof Array) {
        handler_name.forEach(function (name) {
          _this.add(elem, name, event_name);
        });
      } else if (typeof handler_name === 'string') {
        this.add(elem, handler_name, event_name);
      } else {
        result = false;
      }

      return result;
    } // Добавить обработчик с переданным именем на элемент

  }, {
    key: "add",
    value: function add(elem, handler_name) {
      var event_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.default_event_name;
      if (!elem || !handler_name || !this.getHandler(handler_name)) return false;
      elem.addEventListener(event_name, this.getHandler(handler_name));
      return true;
    } // Удалить обработчик с переданным именем с элемента

  }, {
    key: "remove",
    value: function remove(elem, handler_name) {
      var event_name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.default_event_name;
      if (!elem || !handler_name || !this.getHandler(handler_name)) return false;
      elem.removeEventListener(event_name, this.getHandler(handler_name));
      return true;
    } // Удалить все обработчики с элемента

  }, {
    key: "removeAll",
    value: function removeAll(elem) {
      var event_name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.default_event_name;
      if (!elem) return false;

      for (var handler in this.handlers) {
        elem.removeEventListener(event_name, this.getHandler(handler));
      }

      return true;
    } // Получить имена всех обработчиков

  }, {
    key: "getHandlersNames",
    value: function getHandlersNames() {
      return Object.keys(this.handlers);
    } // Получить объект всех функций-обработчиков

  }, {
    key: "getHandlers",
    value: function getHandlers() {
      return this.handlers;
    } // Получить функцию-обработчик

  }, {
    key: "getHandler",
    value: function getHandler(handler_name) {
      return this.handlers[handler_name];
    } // === Обработчики ===

  }, {
    key: "_testHandler",
    value: function _testHandler() {
      alert('_testHandler');
    } // Отменяет действие браузера

  }, {
    key: "_preventHandler",
    value: function _preventHandler(e) {
      e.preventDefault();
      return false;
    } // Останавливает всплытие, другие обработчики и отменяет действие браузера

  }, {
    key: "_preventStopHandler",
    value: function _preventStopHandler(e) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      return false;
    } // Обработчик кнопки для режима открытия в новой вкладке

  }, {
    key: "_newTabHandler",
    value: function _newTabHandler() {
      return true;
    } // Обработчик кнопки для режима скачивания

  }, {
    key: "_downloadHandler",
    value: function _downloadHandler(e) {
      e.preventDefault();
      (0, _downloadjs.default)(e.currentTarget.href);
      return false;
    }
  }]);

  return HandlersManager;
}();

exports.default = HandlersManager;

},{"downloadjs":5}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _templates = _interopRequireDefault(require("./templates"));

var _handlers = _interopRequireDefault(require("./handlers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PhotoDownload =
/*#__PURE__*/
function () {
  function PhotoDownload() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PhotoDownload);

    var that = this; // Ссылка, в которую обернута картинка, 
    // здесь нужнв для триггера создания/обновления кнопки

    this.imgContainer_id = 'pv_photo'; // Объект всех селекторов, использующихся в кнопке

    this.selectors = {
      // id контейнера кнопки
      photoDownload_id: 'PhotoDownload',
      // Контейнер, в котором находится картинка и элементы управления,
      // создавать кнопку будем в нем
      imgContainer_class: 'pv_image_wrap',
      // id, который добавится тегу style
      style_id: 'PhotoDownloadStyle',
      // Класс кнопки (тега a)
      PhotoDownload_btn: 'PhotoDownload_btn',
      // Класс блока иконки
      PhotoDownload_icon: 'PhotoDownload_icon',
      // Класс блока, в котором отображается разрешение картинки
      PhotoDownload_size: 'PhotoDownload_size',
      // Класс-флаг, вешается на .PhotoDownload_size когда нет данных о разрешении
      non_size: 'non_size',
      // Класс-флаг, вешается для плавного opacity кнопки после создания
      ready: 'ready'
    }; // Объект с описанием обработчиков

    this.triggers = {
      mouseover: [// Селектор ссылки, в которую обернута картинка в просмотрщике
      {
        type: 'id',
        selector: this.imgContainer_id,
        // При наведении на контейнер картинки, будем обновлять(создавать) кнопку
        handler: this._updateBtn,
        child: true
      }, // Селектор родительского блока кнопки
      {
        type: 'class',
        selector: this.selectors.PhotoDownload_btn,
        // При наведении на саму кнопку, будем обновлять в ней данные
        handler: this._updateBtn,
        child: true
      }] // Конец mouseover

    }; // Флаг, задающий поведение клика по кнопке
    // Если true, то картинка будет скачиваться
    // Если false, то картинка будет открываться в новой вкладке

    this.flag_download = {
      _flag: params.download,

      get flag() {
        return this._flag;
      },

      set flag(val) {
        if (typeof val === 'boolean') {
          this._flag = val;

          that._addBtnHandlers(this._flag);
        }
      }

    }; // Здесь будет храниться элемент кнопки

    this.wrap = null; // Создаем инстанс шаблонизатора верстки

    this.template = new _templates.default({
      selectors: this.selectors
    }); // Создаем инстанс контроллера событий внутри кнопки

    this.handlers = new _handlers.default({
      PhotoDownload: this
    }); // Точка входа

    this.init();
  } // Добавляет на кнопку обработчики скачивания/открытия в новой вкладке


  _createClass(PhotoDownload, [{
    key: "_addBtnHandlers",
    value: function _addBtnHandlers() {
      if (!this.wrap) return false;
      var btn = this.wrap.querySelector('.' + this.selectors.PhotoDownload_btn); // В зависимости от флага вешаем либо обработчик скачивания, либо открытия новой вкладки

      if (this.flag_download.flag) {
        this.handlers.set(btn, 'downloadHandler');
      } else {
        this.handlers.set(btn, 'newTabHandler');
      }
    } // Метод обновления данных в кнопке

  }, {
    key: "_updateBtn",
    value: function _updateBtn(elem) {
      this.parent = elem.closest('.' + this.selectors.imgContainer_class); // Если в родительском контейнере еще нет кнопки

      if (!this.parent.querySelector('#' + this.selectors.photoDownload_id)) {
        // то создадим ее
        this.wrap = this.template.createDownloadContainer(this.parent); // И повесим на нее обработчики

        this._addBtnHandlers();
      }

      var btn = this.wrap.querySelector('.' + this.selectors.PhotoDownload_btn);
      var size = this.wrap.querySelector('.' + this.selectors.PhotoDownload_size); // Получаем из недр ВК информацию о максимальной версии открытой в просмотрщике картинки

      var image_data = window.Photoview.genData(window.cur.pvCurPhoto); // Если ссылка в кнопке не та, которая нужна сейчас

      if (btn.href !== image_data.src) {
        // Обновим ссылку в кнопке
        btn.href = image_data.src; // И размеры картинки, которая по ссылке

        this.template.setSize(size, image_data);
      }
    } // Проверка на то, является ли цель события дочерним элементом селектора из объекта триггеров

  }, {
    key: "_checkComplianceChild",
    value: function _checkComplianceChild(target, trigger) {
      var parent = trigger.type === 'id' ? target.closest('#' + trigger.selector) : target.closest('.' + trigger.selector);

      if (parent) {
        // Если да, запустим обработчик для родителя
        this._checkComplianceTarget(parent, trigger);
      }
    } // Проверка на соответствие цели события с селекторами объекта триггеров

  }, {
    key: "_checkComplianceTarget",
    value: function _checkComplianceTarget(target, trigger) {
      var compliance = false; // Два отдельных условия для того, чтобы была возможность назначить
      // разные обработчики по id и по классу на один элемент, и они сработали оба

      if (trigger.type === 'id') {
        if (target.id === trigger.selector) {
          compliance = true;

          if (trigger.handler) {
            trigger.handler.call(this, target);
          }
        }
      }

      if (trigger.type === 'class') {
        if (target.classList.contains(trigger.selector)) {
          compliance = true;

          if (trigger.handler) {
            trigger.handler.call(this, target);
          }
        }
      }

      return compliance;
    } // Метод, который вызывает нужный обработчик при нужном событии

  }, {
    key: "_watchTrigger",
    value: function _watchTrigger(event) {
      var _this = this;

      // Смотрим, есть ли обработчики полученного типа события
      // На самом деле они всегда должны быть, но все же
      var triggers = this.triggers[event.type];
      if (triggers === undefined) return; // Берем элемент, на котором сработало событие

      var target = event.target; // Цикл по объекту обработчиков полученного типа события

      triggers.forEach(function (trigger) {
        // Ищем обработчик для цели события
        // Если вернется false, то не найден
        var compliance = _this._checkComplianceTarget(target, trigger); // Если цели события нет в объекте обработчиков, но в обработчике указано, 
        // что он может срабатывать на дочернем элементе


        if (!compliance && trigger.child) {
          // Попробуем найти родительский элемент цели, соответствующий селектору
          // из объекта обработчиков
          _this._checkComplianceChild(target, trigger);
        }
      });
    } // Установка на document слушателей типов событий, имеющихся в объекте обработчиков

  }, {
    key: "_initWatcher",
    value: function _initWatcher() {
      var _this2 = this;

      var types = Object.keys(this.triggers);
      types.forEach(function (type) {
        return document.addEventListener(type, _this2._watchTrigger.bind(_this2));
      });
    } // Метод добавления на страницу стилей, необходимых для работы PhotoDownload

  }, {
    key: "_injectCSS",
    value: function _injectCSS() {
      var style = document.createElement('style');
      style.id = this.selectors.style_id;
      style.textContent = this.template.getStyleContent();
      document.head.appendChild(style);
    } // Точка входа

  }, {
    key: "init",
    value: function init() {
      console.log('%c%s', window.log_color ? window.log_color.blue : '', 'PhotoDownload: Init'); // Добавляем стили PhotoDownload

      this._injectCSS(); // Инициализируем обработчики глобальных событий на document


      this._initWatcher();
    }
  }]);

  return PhotoDownload;
}();

exports.default = PhotoDownload;

},{"./handlers":1,"./templates":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// Класс для шаблонизации верстки кнопки и ее стилей
var PhotoDownloadTemplates =
/*#__PURE__*/
function () {
  function PhotoDownloadTemplates() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PhotoDownloadTemplates);

    // Переданный объект селекторов
    this.selectors = params.selectors; // Объект, генерирующий разноцветные иконки

    this.icons = {
      _colors: {
        green: '#00B75A',
        red: '#F92672',
        white: '#FFFFFF',
        yellow: '#FFC000'
      },
      _prefix: 'data:image/svg+xml;charset=utf-8,',

      /* html */
      _template: "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\">\n                            <path fill=\"{{color}}\" d=\"M 4,0 4,8 0,8 8,16 16,8 12,8 12,0 4,0 z\"/>\n                        </svg>",
      _temp: function _temp(color) {
        return this._template.replace(/\{\{.*\}\}/gm, color ? color : 'white');
      },
      get: function get(color) {
        var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var _color = this._colors[color] ? this._colors[color] : color;

        var svg = this._temp(_color).replace(/[\s]{2,}/gm, ' ');

        return url ? this._prefix + encodeURIComponent(svg) : svg;
      }
    };
  } // constructor
  // Метод для отображения размеров картинки в кнопке


  _createClass(PhotoDownloadTemplates, [{
    key: "setSize",
    value: function setSize(size, image_data) {
      if (image_data.width && image_data.height) {
        size.classList.remove(this.selectors.non_size);
        size.textContent = "".concat(image_data.width, "x").concat(image_data.height);
      } else {
        size.classList.add(this.selectors.non_size);
        size.textContent = '';
      }
    } // Метод создания контейнера с кнопкой

  }, {
    key: "createDownloadContainer",
    value: function createDownloadContainer(parent) {
      var _this = this;

      var wrap = document.createElement('div');
      wrap.id = this.selectors.photoDownload_id; // Заполнение контейнера внутренними элементами

      wrap.innerHTML = this.getInnerElems();
      setTimeout(function () {
        wrap.classList.add(_this.selectors.ready);
      }, 0);
      parent.appendChild(wrap);
      return wrap;
    } // Метод, генерирующий верстку самой кнопки

  }, {
    key: "getInnerElems",
    value: function getInnerElems() {
      return (
        /* html */
        "\n            <a class=\"".concat(this.selectors.PhotoDownload_btn, "\" href=\"#!\" target=\"_blank\" draggable=\"false\">\n                <div class=\"").concat(this.selectors.PhotoDownload_icon, "\"></div>\n                <div class=\"").concat(this.selectors.PhotoDownload_size, "\"></div>\n            </a>\n        ")
      );
    } // Метод, шаблонизирующий стили кнопки

  }, {
    key: "getStyleContent",
    value: function getStyleContent() {
      return (
        /* css */
        "\n        #".concat(this.selectors.photoDownload_id, " {\n            background-color: #000;\n            border-top-left-radius: 4px;\n            position: absolute;\n            bottom: 0;\n            left: 100%;\n            opacity: 0;\n            transform: translate3d(-38px, 0, 1px);\n            will-change: transform, opacity;\n            transition: opacity .25s ease-in-out, transform .25s ease-in-out !important;\n        }\n        .").concat(this.selectors.imgContainer_class, ":hover #").concat(this.selectors.photoDownload_id, ".").concat(this.selectors.ready, " {\n            opacity: .3;\n        }\n        .").concat(this.selectors.imgContainer_class, " #").concat(this.selectors.photoDownload_id, ".").concat(this.selectors.ready, ":hover {\n            opacity: .8;\n            transform: translate3d(-100%, 0, 1px);\n        }\n        .").concat(this.selectors.PhotoDownload_btn, " {\n            display: flex;\n            align-items: center;\n            padding: 10px;\n        }\n        .").concat(this.selectors.PhotoDownload_btn, ":hover {\n            text-decoration: none;\n        }\n        .").concat(this.selectors.PhotoDownload_icon, " {\n            background-image: url('").concat(this.icons.get('white'), "');\n            background-size: contain;\n            background-repeat: no-repeat;\n            height: 18px;\n            width: 18px;\n        }\n        .").concat(this.selectors.PhotoDownload_btn, ":hover .").concat(this.selectors.PhotoDownload_icon, " {\n            background-image: url('").concat(this.icons.get('green'), "');\n        }\n        #").concat(this.selectors.photoDownload_id, " .").concat(this.selectors.PhotoDownload_size, ":not(.").concat(this.selectors.non_size, ") {\n            padding-left: 10px;\n            color: #C3CFE0 !important;\n        }\n        ")
      );
    } // getStyleContent

  }]);

  return PhotoDownloadTemplates;
}();

exports.default = PhotoDownloadTemplates;

},{}],4:[function(require,module,exports){
"use strict";

var _photoDownload = _interopRequireDefault(require("./modules/photo-download"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.photoDownload = new _photoDownload.default({
  download: true
});

},{"./modules/photo-download":2}],5:[function(require,module,exports){
//download.js v4.2, by dandavis; 2008-2016. [MIT] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.
// v4 adds AMD/UMD, commonJS, and plain browser support
// v4.1 adds url download capability via solo URL argument (same domain/CORS only)
// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors
// https://github.com/rndme/download

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.download = factory();
  }
}(this, function () {

	return function download(data, strFileName, strMimeType) {

		var self = window, // this script is only for browsers anyway...
			defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads
			mimeType = strMimeType || defaultMime,
			payload = data,
			url = !strFileName && !strMimeType && payload,
			anchor = document.createElement("a"),
			toString = function(a){return String(a);},
			myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),
			fileName = strFileName || "download",
			blob,
			reader;
			myBlob= myBlob.call ? myBlob.bind(self) : Blob ;
	  
		if(String(this)==="true"){ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
			payload=[payload, mimeType];
			mimeType=payload[0];
			payload=payload[1];
		}


		if(url && url.length< 2048){ // if no filename and no mime, assume a url was passed as the only argument
			fileName = url.split("/").pop().split("?")[0];
			anchor.href = url; // assign href prop to temp anchor
		  	if(anchor.href.indexOf(url) !== -1){ // if the browser determines that it's a potentially valid url path:
        		var ajax=new XMLHttpRequest();
        		ajax.open( "GET", url, true);
        		ajax.responseType = 'blob';
        		ajax.onload= function(e){ 
				  download(e.target.response, fileName, defaultMime);
				};
        		setTimeout(function(){ ajax.send();}, 0); // allows setting custom ajax headers using the return:
			    return ajax;
			} // end if valid url?
		} // end if url?


		//go ahead and download dataURLs right away
		if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)){
		
			if(payload.length > (1024*1024*1.999) && myBlob !== toString ){
				payload=dataUrlToBlob(payload);
				mimeType=payload.type || defaultMime;
			}else{			
				return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:
					navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :
					saver(payload) ; // everyone else can save dataURLs un-processed
			}
			
		}else{//not data url, is it a string with special needs?
			if(/([\x80-\xff])/.test(payload)){			  
				var i=0, tempUiArr= new Uint8Array(payload.length), mx=tempUiArr.length;
				for(i;i<mx;++i) tempUiArr[i]= payload.charCodeAt(i);
			 	payload=new myBlob([tempUiArr], {type: mimeType});
			}		  
		}
		blob = payload instanceof myBlob ?
			payload :
			new myBlob([payload], {type: mimeType}) ;


		function dataUrlToBlob(strUrl) {
			var parts= strUrl.split(/[:;,]/),
			type= parts[1],
			decoder= parts[2] == "base64" ? atob : decodeURIComponent,
			binData= decoder( parts.pop() ),
			mx= binData.length,
			i= 0,
			uiArr= new Uint8Array(mx);

			for(i;i<mx;++i) uiArr[i]= binData.charCodeAt(i);

			return new myBlob([uiArr], {type: type});
		 }

		function saver(url, winMode){

			if ('download' in anchor) { //html5 A[download]
				anchor.href = url;
				anchor.setAttribute("download", fileName);
				anchor.className = "download-js-link";
				anchor.innerHTML = "downloading...";
				anchor.style.display = "none";
				document.body.appendChild(anchor);
				setTimeout(function() {
					anchor.click();
					document.body.removeChild(anchor);
					if(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(anchor.href);}, 250 );}
				}, 66);
				return true;
			}

			// handle non-a[download] safari as best we can:
			if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
				if(/^data:/.test(url))	url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
				if(!window.open(url)){ // popup blocked, offer direct download:
					if(confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")){ location.href=url; }
				}
				return true;
			}

			//do iframe dataURL download (old ch+FF):
			var f = document.createElement("iframe");
			document.body.appendChild(f);

			if(!winMode && /^data:/.test(url)){ // force a mime that will download:
				url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
			}
			f.src=url;
			setTimeout(function(){ document.body.removeChild(f); }, 333);

		}//end saver




		if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
			return navigator.msSaveBlob(blob, fileName);
		}

		if(self.URL){ // simple fast and modern way using Blob and URL:
			saver(self.URL.createObjectURL(blob), true);
		}else{
			// handle non-Blob()+non-URL browsers:
			if(typeof blob === "string" || blob.constructor===toString ){
				try{
					return saver( "data:" +  mimeType   + ";base64,"  +  self.btoa(blob)  );
				}catch(y){
					return saver( "data:" +  mimeType   + "," + encodeURIComponent(blob)  );
				}
			}

			// Blob but not URL support:
			reader=new FileReader();
			reader.onload=function(e){
				saver(this.result);
			};
			reader.readAsDataURL(blob);
		}
		return true;
	}; /* end download() */
}));

},{}]},{},[4])

//# sourceMappingURL=maps/vk-photo-download.min.js.map
