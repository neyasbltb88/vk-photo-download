(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _downloadjs = _interopRequireDefault(require("downloadjs"));

var _templates = _interopRequireDefault(require("./templates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PhotoDownload =
/*#__PURE__*/
function () {
  function PhotoDownload() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PhotoDownload);

    // Ссылка, в которую обернута картинка, 
    // здесь нужнв для триггера создания/обновления кнопки
    this.imgContainer_id = 'pv_photo'; // Флаг, задающий поведение клика по кнопке
    // Если true, то картинка будет скачиваться
    // Если false, то картинка будет открываться в новой вкладке

    this.flag_download = params.download;
    this.selectors = {
      // id контейнера кнопки
      photoDownload_id: 'PhotoDownload',
      // Контейнер, в котором находится картинка и элементы управления,
      // создавать кнопку будем в нем
      imgContainer_class: 'pv_image_wrap',
      // id, который добавится тегу style
      style_id: 'PhotoDownloadStyle',
      // Класс кнопки (тега a)
      PhotoDownload_btn: 'PhotoDownload_btn',
      // Класс блока иконки
      PhotoDownload_icon: 'PhotoDownload_icon',
      // Класс блока, в котором отображается разрешение картинки
      PhotoDownload_size: 'PhotoDownload_size',
      // Класс-флаг, вешается на .PhotoDownload_size когда нет данных о разрешении
      non_size: 'non_size',
      // Класс-флаг, вешается для плавного opacity кнопки после создания
      ready: 'ready'
    };
    this.template = new _templates.default({
      selectors: this.selectors
    }); // Объект с описанием обработчиков

    this.triggers = {
      mouseover: [// Селектор ссылки, в которую обернута картинка в просмотрщике
      {
        type: 'id',
        selector: this.imgContainer_id,
        handler: this._updateBtn,
        child: true
      }, {
        type: 'class',
        selector: this.selectors.PhotoDownload_btn,
        handler: this._updateBtn,
        child: true
      }] // Конец mouseover

    };
    this.last_image_data = {
      src: null,
      width: null,
      height: null
    }; // Точка входа

    this.init();
  } // Метод обновления данных в кнопке


  _createClass(PhotoDownload, [{
    key: "_updateBtn",
    value: function _updateBtn(elem) {
      var parent = elem.closest('.' + this.selectors.imgContainer_class); // Если в родительском контейнере еще нет кнопки

      if (!parent.querySelector('#' + this.selectors.photoDownload_id)) {
        // то создадим ее
        this._createDownloadContainer(elem);
      }

      var btn = parent.querySelector('.' + this.selectors.PhotoDownload_btn);
      var size = parent.querySelector('.' + this.selectors.PhotoDownload_size);
      this.last_image_data = window.Photoview.genData(window.cur.pvCurPhoto); // Если ссылка в кнопке не та, которая нужна сейчас

      if (btn.href !== this.last_image_data.src) {
        btn.href = this.last_image_data.src; // Если флаг true, вешаем обработчик для скачивания картинки

        if (this.flag_download) {
          btn.onclick = function (e) {
            e.preventDefault();
            (0, _downloadjs.default)(e.currentTarget.href);
            return false;
          };
        } else {
          btn.onclick = null;
        }

        if (this.last_image_data.width && this.last_image_data.height) {
          size.classList.remove(this.selectors.non_size);
          size.textContent = "".concat(this.last_image_data.width, "x").concat(this.last_image_data.height);
        } else {
          size.classList.add(this.selectors.non_size);
          size.textContent = '';
        }
      }
    } // Метод создания контейнера с кнопкой

  }, {
    key: "_createDownloadContainer",
    value: function _createDownloadContainer(elem) {
      var parent = elem.closest('.' + this.selectors.imgContainer_class);
      var wrap = document.createElement('div');
      wrap.id = this.selectors.photoDownload_id;
      wrap.innerHTML = this.template.getInnerElems();
      setTimeout(function () {
        wrap.classList.add('ready');
      }, 0);
      parent.appendChild(wrap);
    } // Проверка на то, является ли цель события дочерним элементом селектора из объекта триггеров

  }, {
    key: "_checkComplianceChild",
    value: function _checkComplianceChild(target, trigger) {
      var parent = trigger.type === 'id' ? target.closest('#' + trigger.selector) : target.closest('.' + trigger.selector);

      if (parent) {
        this._checkComplianceTarget(parent, trigger);
      }
    } // Проверка на соответствие цели события с селекторами объекта триггеров

  }, {
    key: "_checkComplianceTarget",
    value: function _checkComplianceTarget(target, trigger) {
      var compliance = false; // Два отдельных условия для того, чтобы была возможность назначить
      // разные обработчики по id и по классу на один элемент, и они сработали оба

      if (trigger.type === 'id') {
        if (target.id === trigger.selector) {
          compliance = true;

          if (trigger.handler) {
            trigger.handler.call(this, target);
          }
        }
      }

      if (trigger.type === 'class') {
        if (target.classList.contains(trigger.selector)) {
          compliance = true;

          if (trigger.handler) {
            trigger.handler.call(this, target);
          }
        }
      }

      return compliance;
    } // Метод, который вызывает нужный обработчик при нужном событии

  }, {
    key: "_watchTrigger",
    value: function _watchTrigger(event) {
      var _this = this;

      // Смотрим, есть ли обработчики полученного типа события
      // На самом деле они всегда должны быть, но все же
      var triggers = this.triggers[event.type];
      if (triggers === undefined) return; // Берем элемент, на котором сработало событие

      var target = event.target; // Цикл по объекту обработчиков полученного типа события

      triggers.forEach(function (trigger) {
        // Если цели события нет в объекте обработчиков, но в обработчике указано, 
        // что он может срабатывать на дочернем элементе
        if (!_this._checkComplianceTarget(target, trigger) && trigger.child) {
          // Попробуем найти родительский элемент цели, соответствующий селектору
          // из объекта обработчиков
          _this._checkComplianceChild(target, trigger);
        }
      });
    } // Установка на document слушателей типов событий, имеющихся в объекте обработчиков

  }, {
    key: "_initWatcher",
    value: function _initWatcher() {
      var _this2 = this;

      var types = Object.keys(this.triggers);
      types.forEach(function (type) {
        return document.addEventListener(type, _this2._watchTrigger.bind(_this2));
      });
    } // Метод добавления на страницу стилей, необходимых для работы PhotoDownload

  }, {
    key: "_injectCSS",
    value: function _injectCSS() {
      var style = document.createElement('style');
      style.id = this.selectors.style_id;
      style.textContent = this.template.getStyleContent();
      document.head.appendChild(style);
    } // Точка входа

  }, {
    key: "init",
    value: function init() {
      console.log('%c%s', window.log_color ? window.log_color.blue : '', 'PhotoDownload: Init'); // Добавляем стили PhotoDownload

      this._injectCSS(); // Инициализируем обработчики событий


      this._initWatcher();
    }
  }]);

  return PhotoDownload;
}();

exports.default = PhotoDownload;

},{"./templates":2,"downloadjs":4}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var PhotoDownloadTemplates =
/*#__PURE__*/
function () {
  function PhotoDownloadTemplates() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, PhotoDownloadTemplates);

    this.selectors = params.selectors; // Объект, генерирующий разноцветные иконки

    this.icons = {
      _colors: {
        green: '#00B75A',
        red: '#F92672',
        white: '#FFFFFF',
        yellow: '#FFC000'
      },
      _prefix: 'data:image/svg+xml;charset=utf-8,',

      /* html */
      _template: "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\">\n                            <path fill=\"{{color}}\" d=\"M 4,0 4,8 0,8 8,16 16,8 12,8 12,0 4,0 z\"/>\n                        </svg>",
      _temp: function _temp(color) {
        return this._template.replace(/\{\{.*\}\}/gm, color ? color : 'white');
      },
      get: function get(color) {
        var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var _color = this._colors[color] ? this._colors[color] : color;

        var svg = this._temp(_color).replace(/[\s]{2,}/gm, ' ');

        return url ? this._prefix + encodeURIComponent(svg) : svg;
      }
    };
  } // constructor


  _createClass(PhotoDownloadTemplates, [{
    key: "getInnerElems",
    value: function getInnerElems() {
      return (
        /* html */
        "\n            <a class=\"".concat(this.selectors.PhotoDownload_btn, "\" href=\"#!\" target=\"_blank\" draggable=\"false\">\n                <div class=\"").concat(this.selectors.PhotoDownload_icon, "\"></div>\n                <div class=\"").concat(this.selectors.PhotoDownload_size, "\"></div>\n            </a>\n        ")
      );
    }
  }, {
    key: "getStyleContent",
    value: function getStyleContent() {
      return (
        /* css */
        "\n        #".concat(this.selectors.photoDownload_id, " {\n            background-color: #000;\n            border-top-left-radius: 4px;\n            position: absolute;\n            bottom: 0;\n            left: 100%;\n            opacity: 0;\n            transform: translate3d(-38px, 0, 1px);\n            will-change: transform, opacity;\n            transition: opacity .25s ease-in-out, transform .25s ease-in-out !important;\n        }\n        .").concat(this.selectors.imgContainer_class, ":hover #").concat(this.selectors.photoDownload_id, ".").concat(this.selectors.ready, " {\n            opacity: .3;\n        }\n        .").concat(this.selectors.imgContainer_class, " #").concat(this.selectors.photoDownload_id, ".").concat(this.selectors.ready, ":hover {\n            opacity: .8;\n            transform: translate3d(-100%, 0, 1px);\n        }\n        .").concat(this.selectors.PhotoDownload_btn, " {\n            display: flex;\n            align-items: center;\n            padding: 10px;\n        }\n        .").concat(this.selectors.PhotoDownload_btn, ":hover {\n            text-decoration: none;\n        }\n        .").concat(this.selectors.PhotoDownload_icon, " {\n            background-image: url('").concat(this.icons.get('white'), "');\n            background-size: contain;\n            background-repeat: no-repeat;\n            height: 18px;\n            width: 18px;\n        }\n        .").concat(this.selectors.PhotoDownload_btn, ":hover .").concat(this.selectors.PhotoDownload_icon, " {\n            background-image: url('").concat(this.icons.get('green'), "');\n        }\n        #").concat(this.selectors.photoDownload_id, " .").concat(this.selectors.PhotoDownload_size, ":not(.").concat(this.selectors.non_size, ") {\n            padding-left: 10px;\n            color: #C3CFE0 !important;\n        }\n        ")
      );
    } // getStyleContent

  }]);

  return PhotoDownloadTemplates;
}();

exports.default = PhotoDownloadTemplates;

},{}],3:[function(require,module,exports){
"use strict";

var _photoDownload = _interopRequireDefault(require("./modules/photo-download"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

window.photoDownload = new _photoDownload.default({
  download: true
});

},{"./modules/photo-download":1}],4:[function(require,module,exports){
//download.js v4.2, by dandavis; 2008-2016. [MIT] see http://danml.com/download.html for tests/usage
// v1 landed a FF+Chrome compat way of downloading strings to local un-named files, upgraded to use a hidden frame and optional mime
// v2 added named files via a[download], msSaveBlob, IE (10+) support, and window.URL support for larger+faster saves than dataURLs
// v3 added dataURL and Blob Input, bind-toggle arity, and legacy dataURL fallback was improved with force-download mime and base64 support. 3.1 improved safari handling.
// v4 adds AMD/UMD, commonJS, and plain browser support
// v4.1 adds url download capability via solo URL argument (same domain/CORS only)
// v4.2 adds semantic variable names, long (over 2MB) dataURL support, and hidden by default temp anchors
// https://github.com/rndme/download

(function (root, factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD. Register as an anonymous module.
		define([], factory);
	} else if (typeof exports === 'object') {
		// Node. Does not work with strict CommonJS, but
		// only CommonJS-like environments that support module.exports,
		// like Node.
		module.exports = factory();
	} else {
		// Browser globals (root is window)
		root.download = factory();
  }
}(this, function () {

	return function download(data, strFileName, strMimeType) {

		var self = window, // this script is only for browsers anyway...
			defaultMime = "application/octet-stream", // this default mime also triggers iframe downloads
			mimeType = strMimeType || defaultMime,
			payload = data,
			url = !strFileName && !strMimeType && payload,
			anchor = document.createElement("a"),
			toString = function(a){return String(a);},
			myBlob = (self.Blob || self.MozBlob || self.WebKitBlob || toString),
			fileName = strFileName || "download",
			blob,
			reader;
			myBlob= myBlob.call ? myBlob.bind(self) : Blob ;
	  
		if(String(this)==="true"){ //reverse arguments, allowing download.bind(true, "text/xml", "export.xml") to act as a callback
			payload=[payload, mimeType];
			mimeType=payload[0];
			payload=payload[1];
		}


		if(url && url.length< 2048){ // if no filename and no mime, assume a url was passed as the only argument
			fileName = url.split("/").pop().split("?")[0];
			anchor.href = url; // assign href prop to temp anchor
		  	if(anchor.href.indexOf(url) !== -1){ // if the browser determines that it's a potentially valid url path:
        		var ajax=new XMLHttpRequest();
        		ajax.open( "GET", url, true);
        		ajax.responseType = 'blob';
        		ajax.onload= function(e){ 
				  download(e.target.response, fileName, defaultMime);
				};
        		setTimeout(function(){ ajax.send();}, 0); // allows setting custom ajax headers using the return:
			    return ajax;
			} // end if valid url?
		} // end if url?


		//go ahead and download dataURLs right away
		if(/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)){
		
			if(payload.length > (1024*1024*1.999) && myBlob !== toString ){
				payload=dataUrlToBlob(payload);
				mimeType=payload.type || defaultMime;
			}else{			
				return navigator.msSaveBlob ?  // IE10 can't do a[download], only Blobs:
					navigator.msSaveBlob(dataUrlToBlob(payload), fileName) :
					saver(payload) ; // everyone else can save dataURLs un-processed
			}
			
		}else{//not data url, is it a string with special needs?
			if(/([\x80-\xff])/.test(payload)){			  
				var i=0, tempUiArr= new Uint8Array(payload.length), mx=tempUiArr.length;
				for(i;i<mx;++i) tempUiArr[i]= payload.charCodeAt(i);
			 	payload=new myBlob([tempUiArr], {type: mimeType});
			}		  
		}
		blob = payload instanceof myBlob ?
			payload :
			new myBlob([payload], {type: mimeType}) ;


		function dataUrlToBlob(strUrl) {
			var parts= strUrl.split(/[:;,]/),
			type= parts[1],
			decoder= parts[2] == "base64" ? atob : decodeURIComponent,
			binData= decoder( parts.pop() ),
			mx= binData.length,
			i= 0,
			uiArr= new Uint8Array(mx);

			for(i;i<mx;++i) uiArr[i]= binData.charCodeAt(i);

			return new myBlob([uiArr], {type: type});
		 }

		function saver(url, winMode){

			if ('download' in anchor) { //html5 A[download]
				anchor.href = url;
				anchor.setAttribute("download", fileName);
				anchor.className = "download-js-link";
				anchor.innerHTML = "downloading...";
				anchor.style.display = "none";
				document.body.appendChild(anchor);
				setTimeout(function() {
					anchor.click();
					document.body.removeChild(anchor);
					if(winMode===true){setTimeout(function(){ self.URL.revokeObjectURL(anchor.href);}, 250 );}
				}, 66);
				return true;
			}

			// handle non-a[download] safari as best we can:
			if(/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
				if(/^data:/.test(url))	url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
				if(!window.open(url)){ // popup blocked, offer direct download:
					if(confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")){ location.href=url; }
				}
				return true;
			}

			//do iframe dataURL download (old ch+FF):
			var f = document.createElement("iframe");
			document.body.appendChild(f);

			if(!winMode && /^data:/.test(url)){ // force a mime that will download:
				url="data:"+url.replace(/^data:([\w\/\-\+]+)/, defaultMime);
			}
			f.src=url;
			setTimeout(function(){ document.body.removeChild(f); }, 333);

		}//end saver




		if (navigator.msSaveBlob) { // IE10+ : (has Blob, but not a[download] or URL)
			return navigator.msSaveBlob(blob, fileName);
		}

		if(self.URL){ // simple fast and modern way using Blob and URL:
			saver(self.URL.createObjectURL(blob), true);
		}else{
			// handle non-Blob()+non-URL browsers:
			if(typeof blob === "string" || blob.constructor===toString ){
				try{
					return saver( "data:" +  mimeType   + ";base64,"  +  self.btoa(blob)  );
				}catch(y){
					return saver( "data:" +  mimeType   + "," + encodeURIComponent(blob)  );
				}
			}

			// Blob but not URL support:
			reader=new FileReader();
			reader.onload=function(e){
				saver(this.result);
			};
			reader.readAsDataURL(blob);
		}
		return true;
	}; /* end download() */
}));

},{}]},{},[3])

//# sourceMappingURL=maps/vk-photo-download.min.js.map
